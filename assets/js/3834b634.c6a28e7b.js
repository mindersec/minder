"use strict";(self.webpackChunkstacklok=self.webpackChunkstacklok||[]).push([[806],{5969:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=i(74848),s=i(28453);const r={},o="Writing Rules Using Rego",a={id:"how-to/writing-rules-in-rego",title:"Writing Rules Using Rego",description:"Minder's policy engine is able to use pluggable drivers for evaluating rules. Rego is a language specifically designed for expressing policies in a clear and concise manner. Its declarative syntax makes it an excellent choice for defining policy logic. In the context of Minder, Rego plays a central role in crafting Rule Types, which are used to enforce security policies.",source:"@site/docs/how-to/writing-rules-in-rego.md",sourceDirName:"how-to",slug:"/how-to/writing-rules-in-rego",permalink:"/how-to/writing-rules-in-rego",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"minder",previous:{title:"Using Mindev to develop and debug rule types",permalink:"/how-to/mindev"},next:{title:"Run the Server",permalink:"/run_minder_server/run_the_server"}},l={},c=[{value:"Rego Evaluation types",id:"rego-evaluation-types",level:2},{value:"Custom Rego functions",id:"custom-rego-functions",level:2},{value:"Example: CodeQL-Enabled Check",id:"example-codeql-enabled-check",level:2},{value:"Example: No &#39;latest&#39; tag in Dockerfile",id:"example-no-latest-tag-in-dockerfile",level:2},{value:"Example: Security Advisories Check",id:"example-security-advisories-check",level:2},{value:"Linting",id:"linting",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"writing-rules-using-rego",children:"Writing Rules Using Rego"}),"\n",(0,t.jsx)(n.p,{children:"Minder's policy engine is able to use pluggable drivers for evaluating rules. Rego is a language specifically designed for expressing policies in a clear and concise manner. Its declarative syntax makes it an excellent choice for defining policy logic. In the context of Minder, Rego plays a central role in crafting Rule Types, which are used to enforce security policies."}),"\n",(0,t.jsx)(n.h1,{id:"writing-rule-types-in-minder",children:"Writing Rule Types in Minder"}),"\n",(0,t.jsx)(n.p,{children:"Minder organizes policies into Rule Types, each with specific sections defining how policies are ingested, evaluated, and acted upon. Rule types are then called within profiles to express the security posture of your organization. Let's delve into the essential components of a Minder Rule Type:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Ingesting Data: Fetching relevant data, often from external sources like GitHub API."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Evaluation: Applying policy logic to the ingested data. Minder offers a set of engines to evaluate data: jq and rego being general-purpose engines, while trusty and vulncheck are more use case-specific ones."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Remediation and Alerting: Taking actions or providing notifications based on evaluation results. E.g. creating a pull request or generating a GitHub security advisory."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rego-evaluation-types",children:"Rego Evaluation types"}),"\n",(0,t.jsx)(n.p,{children:"With Rego being a flexible policy language, it allowed us to express policy checks via different constructs. We chose to implement two in Minder:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"deny-by-default"}),": Checks for an allowed boolean being set to true, and denies the policy if it\u2019s not the case."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"constraints"}),": Checks for violations in the given policy. This allows us to express the violations and output them in a user friendly-manner."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Note that these are known patterns in the OPA community, so we\u2019re not doing anything out of the ordinary here. Instead, we leverage best practices that have already been established."}),"\n",(0,t.jsx)(n.h2,{id:"custom-rego-functions",children:"Custom Rego functions"}),"\n",(0,t.jsx)(n.p,{children:"Given the context in which Minder operates, we did need to add some custom functionality that OPA doesn\u2019t provide out of the box. Namely, we added the following custom functions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"file.exists"}),": Verifies that the given file exists in the Git repository."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"file.read"}),": Reads the contents of the given file in the Git repository."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"file.ls"}),": Lists files in the given directory in the Git repository."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"file.ls_glob"}),": Lists files in the given directory in the Git repository that match the given glob pattern."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"file.http_type"}),": Returns the HTTP content type of the given file."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"file.walk"}),": Walks the given directory in the Git repository and lists all files."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"github_workflow.ls_actions"}),": Lists all actions in the given GitHub workflow directory."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-codeql-enabled-check",children:"Example: CodeQL-Enabled Check"}),"\n",(0,t.jsx)(n.p,{children:"CodeQL is a very handy tool that GitHub provides to do static analysis on codebases. In this scenario, we\u2019ll see a rule type that verifies that it\u2019s enabled via a GitHub action in the repository."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"---\nversion: v1\ntype: rule-type\nname: codeql_enabled\ncontext:\n  provider: github\ndescription: Verifies that CodeQL is enabled for the repository\nguidance: |\n  CodeQL is a tool that can be used to analyze code for security vulnerabilities.\n  It is recommended that repositories have some form of static analysis enabled\n  to ensure that vulnerabilities are not introduced into the codebase.\n\n  To enable CodeQL, add a GitHub workflow to the repository that runs the\n  CodeQL analysis.\n\n  For more information, see\n  https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#configuring-code-scanning-for-a-private-repository\ndef:\n  # Defines the section of the pipeline the rule will appear in.\n  # This will affect the template used to render multiple parts\n  # of the rule.\n  in_entity: repository\n  # Defines the schema for writing a rule with this rule being checked\n  rule_schema:\n    type: object\n    properties:\n      languages:\n        type: array\n        items:\n          type: string\n        description: |\n          Only applicable for remediation. Sets the CodeQL languages to use in the workflow.\n          CodeQL supports 'c-cpp', 'csharp', 'go', 'java-kotlin', 'javascript-typescript', 'python', 'ruby', 'swift'\n      schedule_interval:\n        type: string\n        description: |\n          Only applicable for remediation. Sets the schedule interval for the workflow.\n    required:\n      - languages\n      - schedule_interval\n  # Defines the configuration for ingesting data relevant for the rule\n  ingest:\n    type: git\n    git:\n      branch: main\n  # Defines the configuration for evaluating data ingested against the given profile\n  eval:\n    type: rego\n    rego:\n      type: deny-by-default\n      def: |\n        package minder\n\n        default allow := false\n\n        allow {\n            # List all workflows\n            workflows := file.ls(\"./.github/workflows\")\n\n            # Read all workflows\n            some w\n            workflowstr := file.read(workflows[w])\n\n            workflow := yaml.unmarshal(workflowstr)\n\n            # Ensure a workflow contains the codel-ql action\n            some i\n            steps := workflow.jobs.analyze.steps[i]\n            startswith(steps.uses, \"github/codeql-action/analyze@\")\n        }\n  # Defines the configuration for alerting on the rule\n  alert:\n    type: security_advisory\n    security_advisory:\n      severity: \"medium\"\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The rego evaluation uses the ",(0,t.jsx)(n.code,{children:"deny-by-default"})," type. It\u2019ll set the policy as successful if there is a GitHub workflow that instantiates ",(0,t.jsx)(n.code,{children:"github/codeql-action/analyze"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"example-no-latest-tag-in-dockerfile",children:"Example: No 'latest' tag in Dockerfile"}),"\n",(0,t.jsxs)(n.p,{children:["In this scenario, we\u2019ll explore a Rule Type that verifies that a Dockerfile does not use the ",(0,t.jsx)(n.code,{children:"latest"})," tag."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'---\nversion: v1\ntype: rule-type\nname: dockerfile_no_latest_tag\ncontext:\n  provider: github\ndescription: Verifies that the Dockerfile image references don\'t use the latest tag\nguidance: |\n  Using the latest tag for Docker images is not recommended as it can lead to unexpected behavior.\n  It is recommended to use a checksum instead, as that\'s immutable and will always point to the same image.\ndef:\n  # Defines the section of the pipeline the rule will appear in.\n  # This will affect the template used to render multiple parts\n  # of the rule.\n  in_entity: repository\n  # Defines the schema for writing a rule with this rule being checked\n  # In this case there are no settings that need to be configured\n  rule_schema: {}\n  # Defines the configuration for ingesting data relevant for the rule\n  ingest:\n    type: git\n    git:\n      branch: main\n  # Defines the configuration for evaluating data ingested against the given profile\n  # This example verifies that image in the Dockerfile do not use the \'latest\' tag\n  # For example, this will fail:\n  # FROM golang:latest\n  # These will pass:\n  # FROM golang:1.21.4\n  # FROM golang@sha256:337543447173c2238c78d4851456760dcc57c1dfa8c3bcd94cbee8b0f7b32ad0\n  eval:\n    type: rego\n    rego:\n      type: constraints\n      def: |\n        package minder\n\n        violations[{"msg": msg}] {\n          # Read Dockerfile\n          dockerfile := file.read("Dockerfile")\n\n          # Find all lines that start with FROM and have the latest tag\n          from_lines := regex.find_n("(?m)^(FROM .*:latest|FROM --platform=[^ ]+ [^: ]+|FROM (?!scratch$)[^: ]+)( (as|AS) [^ ]+)?$", dockerfile, -1)\n          from_line := from_lines[_]\n\n          msg := sprintf("Dockerfile contains \'latest\' tag in import: %s", [from_line])\n        }\n  # Defines the configuration for alerting on the rule\n  alert:\n    type: security_advisory\n    security_advisory:\n      severity: "medium"\n'})}),"\n",(0,t.jsx)(n.p,{children:"This leverages the constraints Rego evaluation type, which will output a failure for each violation that it finds. This is handy for usability, as it will tell us exactly the lines that are not in conformance with our rules."}),"\n",(0,t.jsx)(n.h2,{id:"example-security-advisories-check",children:"Example: Security Advisories Check"}),"\n",(0,t.jsx)(n.p,{children:"This is a more complex example. Here, we'll explore a Rule Type that checks for open security advisories in a GitHub repository."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'---\nversion: v1\ntype: rule-type\nname: no_open_security_advisories\ncontext:\n  provider: github\ndescription: |\n  Verifies that a repository has no open security advisories based on a given severity threshold.\n\n  The threshold will cause the rule to fail if there are any open advisories at or above the threshold.\n  It is set to `high` by default, but can be overridden by setting the `severity` parameter.\nguidance: |\n  Ensuring that a repository has no open security advisories helps maintain a secure codebase.\n\n  This rule will fail if the repository has unacknowledged security advisories.\n  It will also fail if the repository has no security advisories enabled.\n\n  Security advisories that are closed or published are considered to be acknowledged.\n\n  For more information, see the [GitHub documentation](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/about-repository-security-advisories).\ndef:\n  in_entity: repository\n  rule_schema:\n    type: object\n    properties:\n      severity:\n        type: string\n        enum:\n          - unknown\n          - low\n          - medium\n          - high\n          - critical\n        default: high\n    required:\n      - severity\n  ingest:\n    type: rest\n    rest:\n      endpoint: "/repos/{{.Entity.Owner}}/{{.Entity.Name}}/security-advisories?per_page=100&sort=updated&order=asc"\n      parse: json\n      fallback:\n        # If we don\'t have advisories enabled, we\'ll get a 404\n        - http_code: 404\n          body: |\n            {"fallback": true}\n  eval:\n    type: rego\n    rego:\n      type: constraints\n      violation_format: json\n      def: |\n        package minder\n        \n        import future.keywords.contains\n        import future.keywords.if\n        import future.keywords.in\n        \n        severity_to_number := {\n        \tnull: -1,\n        \t"unknown": -1,\n        \t"low": 0,\n        \t"medium": 1,\n        \t"high": 2,\n        \t"critical": 3,\n        }\n        \n        default threshold := 1\n        \n        threshold := severity_to_number[input.profile.severity] if input.profile.severity != null\n        \n        above_threshold(severity, threshold) if {\n        \tseverity_to_number[severity] >= threshold\n        }\n        \n        had_fallback if {\n        \tinput.ingested.fallback\n        }\n        \n        violations contains {"msg": "Security advisories not enabled."} if {\n        \thad_fallback\n        }\n        \n        violations contains {"msg": "Found open security advisories in or above threshold"} if {\n        \tnot had_fallback\n        \n        \tsome adv in input.ingested\n        \n        \t# Is not withdrawn\n        \tadv.withdrawn_at == null\n        \n        \tadv.state != "closed"\n        \tadv.state != "published"\n        \n        \t# We only care about advisories that are at or above the threshold\n        \tabove_threshold(adv.severity, threshold)\n        }\n  alert:\n    type: security_advisory\n    security_advisory:\n      severity: "medium"\n'})}),"\n",(0,t.jsx)(n.p,{children:"This verifies that a repository does not have untriaged security advisories within a given severity threshold. Thus ensuring that the team is actively taking care of the advisories and publishing or closing them depending on the applicability."}),"\n",(0,t.jsx)(n.h2,{id:"linting",children:"Linting"}),"\n",(0,t.jsxs)(n.p,{children:["In order to enforce correctness and best practices for our rule types, we have a command-line utility called ",(0,t.jsx)(n.a,{href:"https://github.com/stacklok/minder/tree/main/cmd/dev",children:"mindev"})," that has a lint sub-command."]}),"\n",(0,t.jsx)(n.p,{children:"You can run it by doing the following from the Minder repository:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"./bin/mindev ruletype lint -r path/to/rule\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will show you a list of suggestions to fix in your rule type definition."}),"\n",(0,t.jsxs)(n.p,{children:["The Styra team released a tool called ",(0,t.jsx)(n.a,{href:"https://github.com/StyraInc/regal",children:"Regal"}),", which allows us to lint Rego policies for best practices or common issues. We embedded Regal into our own rule linting tool within mindev. So, running ",(0,t.jsx)(n.code,{children:"mindev ruletype lint"})," on a rule type that leverages Rego will also show you OPA-related best practices."]}),"\n",(0,t.jsx)(n.p,{children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"This introductory guide provides a foundation for leveraging Rego and Minder to write policies effectively. Experiment, explore, and tailor these techniques to meet the unique requirements of your projects."}),"\n",(0,t.jsx)(n.p,{children:"Minder is constantly evolving, so don\u2019t be surprised if we soon add more custom functions or even more evaluation engines! The project is in full steam and more features are coming!"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://github.com/stacklok/minder-rules-and-profiles",children:"You can see a list of rule types that we actively maintain here."})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);