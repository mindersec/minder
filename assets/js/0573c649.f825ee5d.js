"use strict";(self.webpackChunkminder_docs=self.webpackChunkminder_docs||[]).push([[6186],{16844:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"ref/rules/artifact_signature","title":"Artifact signature verification","description":"The following rule type is available for checking that an artifact has a valid","source":"@site/docs/ref/rules/artifact_signature.md","sourceDirName":"ref/rules","slug":"/ref/rules/artifact_signature","permalink":"/ref/rules/artifact_signature","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Artifact signature verification","sidebar_position":10},"sidebar":"minder","previous":{"title":"minder version","permalink":"/ref/cli/minder_version"},"next":{"title":"Branch protection rules","permalink":"/ref/rules/branch_protection"}}');var r=i(74848),s=i(28453);const a={title:"Artifact signature verification",sidebar_position:10},c=void 0,l={},o=[{value:"<code>artifact_signature</code> - Verifies that an artifact has a valid signature",id:"artifact_signature---verifies-that-an-artifact-has-a-valid-signature",level:2},{value:"Entity",id:"entity",level:2},{value:"Type",id:"type",level:2},{value:"Rule parameters",id:"rule-parameters",level:2},{value:"Rule definition options",id:"rule-definition-options",level:2}];function d(e){const t={code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"The following rule type is available for checking that an artifact has a valid\nsignature and its provenance conforms to a policy."}),"\n",(0,r.jsxs)(t.h2,{id:"artifact_signature---verifies-that-an-artifact-has-a-valid-signature",children:[(0,r.jsx)(t.code,{children:"artifact_signature"})," - Verifies that an artifact has a valid signature"]}),"\n",(0,r.jsx)(t.p,{children:"This rule allows you to verify that an artifact was signed and that the\nsignature is valid."}),"\n",(0,r.jsx)(t.h2,{id:"entity",children:"Entity"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"artifact"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"type",children:"Type"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.code,{children:"artifact_signature"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"rule-parameters",children:"Rule parameters"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"tags"})," - the tags that should be checked for signatures. If not specified, all\ntags will be checked. If specified, the artifact must be tagged with all of\nthe specified tags in order to be checked."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"tags_regex"})," - a regular expression specifying the tags that should be checked\nfor signatures. If not specified, all tags will be checked. If specified, the\nartifact must be tagged with a tag that matches the regular expression in\norder to be checked."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"name"})," - the name of the artifact that should be checked for signatures. If\nnot specified, all artifacts will be checked."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["It is an error to specify both ",(0,r.jsx)(t.code,{children:"tags"})," and ",(0,r.jsx)(t.code,{children:"tags_regex"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"rule-definition-options",children:"Rule definition options"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"artifact_signature"})," rule has the following options:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"is_signed"})," (bool): Whether the artifact is signed"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"is_verified"})," (bool): Whether the artifact's signature could be verified"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"repository"})," (string): The repository that the artifact was built from"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"branch"})," (string): The branch that the artifact was built from"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"signer_identity"})," (string): The identity of the signer of the artifact, e.g. a\nworkflow name like ",(0,r.jsx)(t.code,{children:"docker-image-build-push.yml"})," for GitHub workflow\nsignatures or an email address"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"runner_environment"})," (string): The environment that the artifact was built in,\ni.e. hosted-runner or self-hosted-runner. Set to ",(0,r.jsx)(t.code,{children:"github-hosted"})," to check for\nartifacts built on a GitHub-hosted runner."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"cert_issuer"})," (string): The issuer of the certificate used to sign the\nartifact, i.e. ",(0,r.jsx)(t.code,{children:"https://token.actions.githubusercontent.com"})," for GitHub\nActions"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>c});var n=i(96540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);