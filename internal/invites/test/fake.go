// SPDX-FileCopyrightText: Copyright 2026 The Minder Authors
// SPDX-License-Identifier: Apache-2.0

// Package test provides a fake implementation of InviteService for testing
// Initially generated by Claude Sonnet 4.5 with the following prompt:
// > Generate a fake for the `InviteService` in the directory `internal/invites/fake`.
// > It should use a lightweight in-memory implementation to support creating and
// > tracking invites for tests.
package test

import (
	"cmp"
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/mindersec/minder/internal/auth"
	"github.com/mindersec/minder/internal/authz"
	"github.com/mindersec/minder/internal/db"
	"github.com/mindersec/minder/internal/invites"
	"github.com/mindersec/minder/internal/util"
	minder "github.com/mindersec/minder/pkg/api/protobuf/go/minder/v1"
	serverconfig "github.com/mindersec/minder/pkg/config/server"
	"github.com/mindersec/minder/pkg/eventer/interfaces"
)

// inviteKey uniquely identifies an invitation by email and project
type inviteKey struct {
	email   string
	project uuid.UUID
}

// storedInvite represents an invitation in memory
type storedInvite struct {
	code           string
	email          string
	project        uuid.UUID
	projectDisplay string
	role           authz.Role
	sponsor        string
	sponsorDisplay string
	createdAt      time.Time
	updatedAt      time.Time
}

// FakeInviteService is an in-memory implementation of InviteService for testing
type FakeInviteService struct {
	mu      sync.RWMutex
	invites map[inviteKey]*storedInvite
	codes   map[string]*storedInvite // Track invites by code for GetInvite

	Time time.Time // Optional fixed time for testing
}

// NewFakeInviteService creates a new fake invite service
func NewFakeInviteService() *FakeInviteService {
	return &FakeInviteService{
		invites: make(map[inviteKey]*storedInvite),
		codes:   make(map[string]*storedInvite),
	}
}

// CreateInvite creates a new user invite in memory
func (f *FakeInviteService) CreateInvite(
	ctx context.Context,
	_ db.Querier,
	_ interfaces.Publisher,
	emailConfig serverconfig.EmailConfig,
	targetProject uuid.UUID,
	authzRole authz.Role,
	inviteeEmail string,
) (*minder.Invitation, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	// Get identity from context
	identity := auth.IdentityFromContext(ctx)
	if identity == nil || identity.String() != identity.UserID {
		return nil, util.UserVisibleError(codes.PermissionDenied, "only human users can create invites")
	}

	// Check if invite already exists
	key := inviteKey{email: inviteeEmail, project: targetProject}
	if _, exists := f.invites[key]; exists {
		return nil, util.UserVisibleError(
			codes.AlreadyExists,
			"invitation for this email and project already exists, use update instead",
		)
	}

	// Create new invite
	now := cmp.Or(f.Time, time.Now())
	invite := &storedInvite{
		code:           invites.GenerateCode(),
		email:          inviteeEmail,
		project:        targetProject,
		projectDisplay: "Test: " + targetProject.String(),
		role:           authzRole,
		sponsor:        identity.String(),
		sponsorDisplay: identity.Human(),
		createdAt:      now,
		updatedAt:      now,
	}

	f.invites[key] = invite
	f.codes[invite.code] = invite

	inviteURL := ""
	if emailConfig.MinderURLBase != "" {
		inviteURL = fmt.Sprintf("%s/join/%s", emailConfig.MinderURLBase, invite.code)
	}

	return &minder.Invitation{
		Role:           invite.role.String(),
		Email:          invite.email,
		Project:        invite.project.String(),
		ProjectDisplay: invite.projectDisplay,
		Code:           invite.code,
		InviteUrl:      inviteURL,
		Sponsor:        invite.sponsor,
		SponsorDisplay: invite.sponsorDisplay,
		CreatedAt:      timestamppb.New(invite.createdAt),
		ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
		Expired:        invites.IsExpired(invite.updatedAt),
	}, nil
}

// UpdateInvite updates an existing invite in memory
func (f *FakeInviteService) UpdateInvite(
	ctx context.Context,
	_ db.Querier,
	_ interfaces.Publisher,
	emailConfig serverconfig.EmailConfig,
	targetProject uuid.UUID,
	authzRole authz.Role,
	inviteeEmail string,
) (*minder.Invitation, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	// Get identity from context
	identity := auth.IdentityFromContext(ctx)
	if identity.String() == "" {
		return nil, status.Errorf(codes.Internal, "failed to get user")
	}

	// Find existing invite
	key := inviteKey{email: inviteeEmail, project: targetProject}
	invite, exists := f.invites[key]
	if !exists {
		return nil, util.UserVisibleError(codes.NotFound, "no invitations found for this email and project")
	}

	// Determine if email should be skipped (role unchanged and updated within 24 hours)
	emailSkipped := invite.role == authzRole && time.Since(invite.updatedAt) <= 24*time.Hour

	// Update the invite
	invite.role = authzRole
	invite.updatedAt = cmp.Or(f.Time, time.Now())
	// codes map is already correct since we're updating in place

	inviteURL := ""
	if emailConfig.MinderURLBase != "" {
		inviteURL = fmt.Sprintf("%s/join/%s", emailConfig.MinderURLBase, invite.code)
	}

	return &minder.Invitation{
		Role:           invite.role.String(),
		Email:          invite.email,
		Project:        invite.project.String(),
		ProjectDisplay: invite.projectDisplay,
		Code:           invite.code,
		InviteUrl:      inviteURL,
		Sponsor:        invite.sponsor,
		SponsorDisplay: invite.sponsorDisplay,
		CreatedAt:      timestamppb.New(invite.createdAt),
		ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
		Expired:        invites.IsExpired(invite.updatedAt),
		EmailSkipped:   emailSkipped,
	}, nil
}

// RemoveInvite removes a user invite from memory by code
func (f *FakeInviteService) RemoveInvite(
	_ context.Context,
	_ db.Querier,
	code string,
) error {
	f.mu.Lock()
	defer f.mu.Unlock()

	// Find existing invite by code
	invite, exists := f.codes[code]
	if !exists {
		return util.UserVisibleError(codes.NotFound, "invitation not found")
	}

	// Remove invite from both maps
	key := inviteKey{email: invite.email, project: invite.project}
	delete(f.invites, key)
	delete(f.codes, code)

	return nil
}

// GetInvite returns an invite by its code, or an error if none is found
func (f *FakeInviteService) GetInvite(
	ctx context.Context,
	_ db.Querier,
	code string,
) (*minder.Invitation, error) {
	f.mu.RLock()
	defer f.mu.RUnlock()

	invite, exists := f.codes[code]
	if !exists {
		return nil, util.UserVisibleError(codes.NotFound, "invitation not found or already used")
	}

	if invite.sponsorDisplay == auth.IdentityFromContext(ctx).Human() {
		return nil, util.UserVisibleError(codes.InvalidArgument, "users cannot accept their own invitations")
	}

	if invites.IsExpired(invite.updatedAt) {
		return nil, util.UserVisibleError(codes.InvalidArgument, "invitation expired")
	}

	return &minder.Invitation{
		Role:           invite.role.String(),
		Email:          invite.email,
		Project:        invite.project.String(),
		ProjectDisplay: invite.projectDisplay,
		Code:           invite.code,
		Sponsor:        invite.sponsor,
		SponsorDisplay: invite.sponsorDisplay,
		CreatedAt:      timestamppb.New(invite.createdAt),
		ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
		Expired:        invites.IsExpired(invite.updatedAt),
	}, nil
}

// GetInvitesForSelf gets all invites for the current user (from context)
func (f *FakeInviteService) GetInvitesForSelf(
	ctx context.Context,
	_ db.Querier,
	_ auth.Resolver,
) ([]*minder.Invitation, error) {
	f.mu.RLock()
	defer f.mu.RUnlock()

	// Get email from JWT context
	identity := auth.IdentityFromContext(ctx)
	if identity == nil {
		return nil, status.Errorf(codes.Internal, "failed to get user identity")
	}

	// In a real implementation, we'd get email from JWT token
	// For the fake, we'll look for invites where sponsor matches or use a simple approach
	// Since we don't have JWT parsing in the fake, we'll return invites for the identity's email
	userEmail := identity.Human() // Simplified - in real impl would parse JWT

	invitations := make([]*minder.Invitation, 0)
	for _, invite := range f.invites {
		if invite.email == userEmail {
			invitations = append(invitations, &minder.Invitation{
				Role:           invite.role.String(),
				Email:          invite.email,
				Project:        invite.project.String(),
				ProjectDisplay: invite.projectDisplay,
				Code:           invite.code,
				Sponsor:        invite.sponsor,
				SponsorDisplay: invite.sponsorDisplay,
				CreatedAt:      timestamppb.New(invite.createdAt),
				ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
				Expired:        invites.IsExpired(invite.updatedAt),
			})
		}
	}

	return invitations, nil
}

// GetInvitesForEmail returns invites for a given email and project
func (f *FakeInviteService) GetInvitesForEmail(
	_ context.Context,
	_ db.Querier,
	targetProject uuid.UUID,
	inviteeEmail string,
) ([]*minder.Invitation, error) {
	f.mu.RLock()
	defer f.mu.RUnlock()

	invitations := make([]*minder.Invitation, 0)
	for _, invite := range f.invites {
		if invite.email == inviteeEmail && invite.project == targetProject {
			invitations = append(invitations, &minder.Invitation{
				Role:           invite.role.String(),
				Email:          invite.email,
				Project:        invite.project.String(),
				ProjectDisplay: invite.projectDisplay,
				Code:           invite.code,
				Sponsor:        invite.sponsor,
				SponsorDisplay: invite.sponsorDisplay,
				CreatedAt:      timestamppb.New(invite.createdAt),
				ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
				Expired:        invites.IsExpired(invite.updatedAt),
			})
		}
	}

	return invitations, nil
}

// ListInvitationsForProject lists all invitations for a project (admin view, no codes)
func (f *FakeInviteService) ListInvitationsForProject(
	_ context.Context,
	_ db.Querier,
	targetProject uuid.UUID,
) ([]*minder.Invitation, error) {
	f.mu.RLock()
	defer f.mu.RUnlock()

	invitations := make([]*minder.Invitation, 0)
	for _, invite := range f.invites {
		if invite.project == targetProject {
			invitations = append(invitations, &minder.Invitation{
				Role:      invite.role.String(),
				Email:     invite.email,
				Project:   invite.project.String(),
				CreatedAt: timestamppb.New(invite.createdAt),
				ExpiresAt: invites.GetExpireIn7Days(invite.updatedAt),
				Expired:   invites.IsExpired(invite.updatedAt),
				Sponsor:   invite.sponsor,
				// SponsorDisplay is left empty; the caller fills it in.
				// Code is explicitly not returned here.
			})
		}
	}

	return invitations, nil
}

// GetInviteByEmailAndProject retrieves an invite by email and project (helper method for testing)
func (f *FakeInviteService) GetInviteByEmailAndProject(email string, project uuid.UUID) (*storedInvite, bool) {
	f.mu.RLock()
	defer f.mu.RUnlock()

	key := inviteKey{email: email, project: project}
	invite, exists := f.invites[key]
	return invite, exists
}

// GetAllInvites returns all invites (helper method for testing)
func (f *FakeInviteService) GetAllInvites() []*storedInvite {
	f.mu.RLock()
	defer f.mu.RUnlock()

	result := make([]*storedInvite, 0, len(f.invites))
	for _, invite := range f.invites {
		result = append(result, invite)
	}
	return result
}

// Clear removes all invites (helper method for testing)
func (f *FakeInviteService) Clear() {
	f.mu.Lock()
	defer f.mu.Unlock()

	f.invites = make(map[inviteKey]*storedInvite)
	f.codes = make(map[string]*storedInvite)
}
