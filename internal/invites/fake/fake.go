// SPDX-FileCopyrightText: Copyright 2026 The Minder Authors
// SPDX-License-Identifier: Apache-2.0

// Package fake provides a fake implementation of InviteService for testing
// Generated by Claude Sonnet 4.5 with the following prompt:
// > Generate a fake for the `InviteService` in the directory `internal/invites/fake`.
// > It should use a lightweight in-memory implementation to support creating and
// > tracking invites for tests.
package fake

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/mindersec/minder/internal/auth"
	"github.com/mindersec/minder/internal/authz"
	"github.com/mindersec/minder/internal/db"
	"github.com/mindersec/minder/internal/invites"
	"github.com/mindersec/minder/internal/util"
	minder "github.com/mindersec/minder/pkg/api/protobuf/go/minder/v1"
	serverconfig "github.com/mindersec/minder/pkg/config/server"
	"github.com/mindersec/minder/pkg/eventer/interfaces"
)

// inviteKey uniquely identifies an invitation by email and project
type inviteKey struct {
	email   string
	project uuid.UUID
}

// storedInvite represents an invitation in memory
type storedInvite struct {
	code           string
	email          string
	project        uuid.UUID
	projectDisplay string
	role           authz.Role
	sponsor        string
	sponsorDisplay string
	createdAt      time.Time
	updatedAt      time.Time
}

// FakeInviteService is an in-memory implementation of InviteService for testing
type FakeInviteService struct {
	mu      sync.RWMutex
	invites map[inviteKey]*storedInvite
}

// NewFakeInviteService creates a new fake invite service
func NewFakeInviteService() *FakeInviteService {
	return &FakeInviteService{
		invites: make(map[inviteKey]*storedInvite),
	}
}

// CreateInvite creates a new user invite in memory
func (f *FakeInviteService) CreateInvite(
	ctx context.Context,
	_ db.Querier,
	_ interfaces.Publisher,
	emailConfig serverconfig.EmailConfig,
	targetProject uuid.UUID,
	authzRole authz.Role,
	inviteeEmail string,
) (*minder.Invitation, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	// Get identity from context
	identity := auth.IdentityFromContext(ctx)
	if identity == nil || identity.String() != identity.UserID {
		return nil, util.UserVisibleError(codes.PermissionDenied, "only human users can create invites")
	}

	// Check if invite already exists
	key := inviteKey{email: inviteeEmail, project: targetProject}
	if _, exists := f.invites[key]; exists {
		return nil, util.UserVisibleError(
			codes.AlreadyExists,
			"invitation for this email and project already exists, use update instead",
		)
	}

	// Create new invite
	now := time.Now()
	invite := &storedInvite{
		code:           invites.GenerateCode(),
		email:          inviteeEmail,
		project:        targetProject,
		projectDisplay: "Test Project",
		role:           authzRole,
		sponsor:        identity.String(),
		sponsorDisplay: identity.Human(),
		createdAt:      now,
		updatedAt:      now,
	}

	f.invites[key] = invite

	inviteURL := ""
	if emailConfig.MinderURLBase != "" {
		inviteURL = fmt.Sprintf("%s/join/%s", emailConfig.MinderURLBase, invite.code)
	}

	return &minder.Invitation{
		Role:           invite.role.String(),
		Email:          invite.email,
		Project:        invite.project.String(),
		ProjectDisplay: invite.projectDisplay,
		Code:           invite.code,
		InviteUrl:      inviteURL,
		Sponsor:        invite.sponsor,
		SponsorDisplay: invite.sponsorDisplay,
		CreatedAt:      timestamppb.New(invite.createdAt),
		ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
		Expired:        invites.IsExpired(invite.updatedAt),
	}, nil
}

// UpdateInvite updates an existing invite in memory
func (f *FakeInviteService) UpdateInvite(
	ctx context.Context,
	_ db.Querier,
	_ interfaces.Publisher,
	emailConfig serverconfig.EmailConfig,
	targetProject uuid.UUID,
	authzRole authz.Role,
	inviteeEmail string,
) (*minder.Invitation, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	// Get identity from context
	identity := auth.IdentityFromContext(ctx)
	if identity.String() == "" {
		return nil, status.Errorf(codes.Internal, "failed to get user")
	}

	// Find existing invite
	key := inviteKey{email: inviteeEmail, project: targetProject}
	invite, exists := f.invites[key]
	if !exists {
		return nil, util.UserVisibleError(codes.NotFound, "no invitations found for this email and project")
	}

	// Determine if email should be skipped (role unchanged and updated within 24 hours)
	emailSkipped := false
	if invite.role == authzRole && time.Since(invite.updatedAt) <= 24*time.Hour {
		emailSkipped = true
	}

	// Update the invite
	invite.role = authzRole
	invite.updatedAt = time.Now()

	inviteURL := ""
	if emailConfig.MinderURLBase != "" {
		inviteURL = fmt.Sprintf("%s/join/%s", emailConfig.MinderURLBase, invite.code)
	}

	return &minder.Invitation{
		Role:           invite.role.String(),
		Email:          invite.email,
		Project:        invite.project.String(),
		ProjectDisplay: invite.projectDisplay,
		Code:           invite.code,
		InviteUrl:      inviteURL,
		Sponsor:        invite.sponsor,
		SponsorDisplay: invite.sponsorDisplay,
		CreatedAt:      timestamppb.New(invite.createdAt),
		ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
		Expired:        invites.IsExpired(invite.updatedAt),
		EmailSkipped:   emailSkipped,
	}, nil
}

// RemoveInvite removes a user invite from memory
func (f *FakeInviteService) RemoveInvite(
	_ context.Context,
	_ db.Querier,
	_ auth.Resolver,
	targetProject uuid.UUID,
	authzRole authz.Role,
	inviteeEmail string,
) (*minder.Invitation, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	// Find existing invite
	key := inviteKey{email: inviteeEmail, project: targetProject}
	invite, exists := f.invites[key]
	if !exists {
		return nil, util.UserVisibleError(codes.NotFound, "no invitations found for this email and project")
	}

	// Check if role matches
	if invite.role != authzRole {
		return nil, util.UserVisibleError(codes.NotFound, "no invitation found for this role and email in the project")
	}

	// Remove invite
	delete(f.invites, key)

	return &minder.Invitation{
		Role:           invite.role.String(),
		Email:          invite.email,
		Project:        invite.project.String(),
		ProjectDisplay: invite.projectDisplay,
		Code:           invite.code,
		Sponsor:        invite.sponsor,
		SponsorDisplay: invite.sponsorDisplay,
		CreatedAt:      timestamppb.New(invite.createdAt),
		ExpiresAt:      invites.GetExpireIn7Days(invite.updatedAt),
		Expired:        invites.IsExpired(invite.updatedAt),
	}, nil
}

// GetInvite retrieves an invite by email and project (helper method for testing)
func (f *FakeInviteService) GetInvite(email string, project uuid.UUID) (*storedInvite, bool) {
	f.mu.RLock()
	defer f.mu.RUnlock()

	key := inviteKey{email: email, project: project}
	invite, exists := f.invites[key]
	return invite, exists
}

// GetAllInvites returns all invites (helper method for testing)
func (f *FakeInviteService) GetAllInvites() []*storedInvite {
	f.mu.RLock()
	defer f.mu.RUnlock()

	result := make([]*storedInvite, 0, len(f.invites))
	for _, invite := range f.invites {
		result = append(result, invite)
	}
	return result
}

// Clear removes all invites (helper method for testing)
func (f *FakeInviteService) Clear() {
	f.mu.Lock()
	defer f.mu.Unlock()

	f.invites = make(map[inviteKey]*storedInvite)
}
