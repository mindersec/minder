// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: invitations.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createInvitation = `-- name: CreateInvitation :one

INSERT INTO user_invites (code, email, role, project, sponsor) VALUES ($1, $2, $3, $4, $5) RETURNING code, email, role, project, sponsor, created_at, updated_at
`

type CreateInvitationParams struct {
	Code    string    `json:"code"`
	Email   string    `json:"email"`
	Role    string    `json:"role"`
	Project uuid.UUID `json:"project"`
	Sponsor int32     `json:"sponsor"`
}

// CreateInvitation creates a new invitation. The code is a secret that is sent
// to the invitee, and the email is the address to which the invitation will be
// sent. The role is the role that the invitee will have when they accept the
// invitation. The project is the project to which the invitee will be invited.
// The sponsor is the user who is inviting the invitee.
func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (UserInvite, error) {
	row := q.db.QueryRowContext(ctx, createInvitation,
		arg.Code,
		arg.Email,
		arg.Role,
		arg.Project,
		arg.Sponsor,
	)
	var i UserInvite
	err := row.Scan(
		&i.Code,
		&i.Email,
		&i.Role,
		&i.Project,
		&i.Sponsor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :one

DELETE FROM user_invites WHERE code = $1 RETURNING code, email, role, project, sponsor, created_at, updated_at
`

// DeleteInvitation deletes an invitation by its code. This is intended to be
// called by a user who has issued an invitation and then accepted it, declined
// it or the sponsor has decided to revoke it.
func (q *Queries) DeleteInvitation(ctx context.Context, code string) (UserInvite, error) {
	row := q.db.QueryRowContext(ctx, deleteInvitation, code)
	var i UserInvite
	err := row.Scan(
		&i.Code,
		&i.Email,
		&i.Role,
		&i.Project,
		&i.Sponsor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvitationByCode = `-- name: GetInvitationByCode :one

SELECT user_invites.code, user_invites.email, user_invites.role, user_invites.project, user_invites.sponsor, user_invites.created_at, user_invites.updated_at, users.identity_subject
FROM user_invites
  JOIN users ON user_invites.sponsor = users.id
WHERE code = $1
`

type GetInvitationByCodeRow struct {
	Code            string    `json:"code"`
	Email           string    `json:"email"`
	Role            string    `json:"role"`
	Project         uuid.UUID `json:"project"`
	Sponsor         int32     `json:"sponsor"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	IdentitySubject string    `json:"identity_subject"`
}

// GetInvitationByCode retrieves an invitation by its code. This is intended to
// be called by a user who has received an invitation email and is following the
// link to accept the invitation or when querying for additional info about the
// invitation.
func (q *Queries) GetInvitationByCode(ctx context.Context, code string) (GetInvitationByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByCode, code)
	var i GetInvitationByCodeRow
	err := row.Scan(
		&i.Code,
		&i.Email,
		&i.Role,
		&i.Project,
		&i.Sponsor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IdentitySubject,
	)
	return i, err
}

const getInvitationsByEmail = `-- name: GetInvitationsByEmail :many

SELECT user_invites.code, user_invites.email, user_invites.role, user_invites.project, user_invites.sponsor, user_invites.created_at, user_invites.updated_at, users.identity_subject
FROM user_invites
  JOIN users ON user_invites.sponsor = users.id
WHERE email = $1
`

type GetInvitationsByEmailRow struct {
	Code            string    `json:"code"`
	Email           string    `json:"email"`
	Role            string    `json:"role"`
	Project         uuid.UUID `json:"project"`
	Sponsor         int32     `json:"sponsor"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	IdentitySubject string    `json:"identity_subject"`
}

// GetInvitationsByEmail retrieves all invitations for a given email address.
// This is intended to be called by a logged in user with their own email address,
// to allow them to accept invitations even if email delivery was not working.
// Note that this requires that the destination email address matches the email
// address of the logged in user in the external identity service / auth token.
// This clarification is related solely for user's ListInvitations calls and does
// not affect to resolving invitations intended for other mail addresses.
func (q *Queries) GetInvitationsByEmail(ctx context.Context, email string) ([]GetInvitationsByEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByEmailRow{}
	for rows.Next() {
		var i GetInvitationsByEmailRow
		if err := rows.Scan(
			&i.Code,
			&i.Email,
			&i.Role,
			&i.Project,
			&i.Sponsor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IdentitySubject,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsByEmailAndProject = `-- name: GetInvitationsByEmailAndProject :many

SELECT user_invites.code, user_invites.email, user_invites.role, user_invites.project, user_invites.sponsor, user_invites.created_at, user_invites.updated_at, users.identity_subject
FROM user_invites
  JOIN users ON user_invites.sponsor = users.id
WHERE email = $1 AND project = $2
`

type GetInvitationsByEmailAndProjectParams struct {
	Email   string    `json:"email"`
	Project uuid.UUID `json:"project"`
}

type GetInvitationsByEmailAndProjectRow struct {
	Code            string    `json:"code"`
	Email           string    `json:"email"`
	Role            string    `json:"role"`
	Project         uuid.UUID `json:"project"`
	Sponsor         int32     `json:"sponsor"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	IdentitySubject string    `json:"identity_subject"`
}

// GetInvitationsByEmailAndProject retrieves all invitations by email and project.
func (q *Queries) GetInvitationsByEmailAndProject(ctx context.Context, arg GetInvitationsByEmailAndProjectParams) ([]GetInvitationsByEmailAndProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByEmailAndProject, arg.Email, arg.Project)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByEmailAndProjectRow{}
	for rows.Next() {
		var i GetInvitationsByEmailAndProjectRow
		if err := rows.Scan(
			&i.Code,
			&i.Email,
			&i.Role,
			&i.Project,
			&i.Sponsor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IdentitySubject,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvitationsForProject = `-- name: ListInvitationsForProject :many

SELECT user_invites.email, role, users.identity_subject, user_invites.created_at, user_invites.updated_at
FROM user_invites
  JOIN users ON user_invites.sponsor = users.id
WHERE project = $1
`

type ListInvitationsForProjectRow struct {
	Email           string    `json:"email"`
	Role            string    `json:"role"`
	IdentitySubject string    `json:"identity_subject"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// ListInvitationsForProject collects the information visible to project
// administrators after an invitation has been issued.  In particular, it
// *does not* report the invitation code, which is a secret intended for
// the invitee.
func (q *Queries) ListInvitationsForProject(ctx context.Context, project uuid.UUID) ([]ListInvitationsForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listInvitationsForProject, project)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvitationsForProjectRow{}
	for rows.Next() {
		var i ListInvitationsForProjectRow
		if err := rows.Scan(
			&i.Email,
			&i.Role,
			&i.IdentitySubject,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationRole = `-- name: UpdateInvitationRole :one

UPDATE user_invites SET role = $2, updated_at = NOW() WHERE code = $1 RETURNING code, email, role, project, sponsor, created_at, updated_at
`

type UpdateInvitationRoleParams struct {
	Code string `json:"code"`
	Role string `json:"role"`
}

// UpdateInvitationRole updates an invitation by its code. This is intended to be
// called by a user who has issued an invitation and then decided to change the
// role of the invitee.
func (q *Queries) UpdateInvitationRole(ctx context.Context, arg UpdateInvitationRoleParams) (UserInvite, error) {
	row := q.db.QueryRowContext(ctx, updateInvitationRole, arg.Code, arg.Role)
	var i UserInvite
	err := row.Scan(
		&i.Code,
		&i.Email,
		&i.Role,
		&i.Project,
		&i.Sponsor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
