// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: invitations.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getInvitationByEmail = `-- name: GetInvitationByEmail :many

SELECT code, role, project, updated_at FROM user_invites WHERE email = $1
`

type GetInvitationByEmailRow struct {
	Code      string    `json:"code"`
	Role      string    `json:"role"`
	Project   uuid.UUID `json:"project"`
	UpdatedAt time.Time `json:"updated_at"`
}

// GetInvitationByEmail retrieves all invitations for a given email address.
// This is intended to be called by a logged in user with their own email address,
// to allow them to accept invitations even if email delivery was not working.
// Note that this requires that the destination email address matches the email
// address of the logged in user in the external identity service / auth token.
func (q *Queries) GetInvitationByEmail(ctx context.Context, email string) ([]GetInvitationByEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationByEmailRow{}
	for rows.Next() {
		var i GetInvitationByEmailRow
		if err := rows.Scan(
			&i.Code,
			&i.Role,
			&i.Project,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvitationsForProject = `-- name: ListInvitationsForProject :many

SELECT user_invites.email, role, users.identity_subject, user_invites.created_at, user_invites.updated_at
FROM user_invites
  JOIN users ON user_invites.sponsor = users.id
WHERE project = $1
`

type ListInvitationsForProjectRow struct {
	Email           string    `json:"email"`
	Role            string    `json:"role"`
	IdentitySubject string    `json:"identity_subject"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

// ListInvitationsForProject collects the information visible to project
// administrators after an invitation has been issued.  In particular, it
// *does not* report the invitation code, which is a secret intended for
// the invitee.
func (q *Queries) ListInvitationsForProject(ctx context.Context, project uuid.UUID) ([]ListInvitationsForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listInvitationsForProject, project)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvitationsForProjectRow{}
	for rows.Next() {
		var i ListInvitationsForProjectRow
		if err := rows.Scan(
			&i.Email,
			&i.Role,
			&i.IdentitySubject,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
