// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: subscriptions.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const bundleExists = `-- name: BundleExists :one
SELECT 1 FROM bundles WHERE namespace = $1 AND name = $2
`

type BundleExistsParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

func (q *Queries) BundleExists(ctx context.Context, arg BundleExistsParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, bundleExists, arg.Namespace, arg.Name)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createBundle = `-- name: CreateBundle :one

INSERT INTO bundles (namespace, name) VALUES ($1, $2) RETURNING id, namespace, name
`

type CreateBundleParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

// Bundles --
func (q *Queries) CreateBundle(ctx context.Context, arg CreateBundleParams) (Bundle, error) {
	row := q.db.QueryRowContext(ctx, createBundle, arg.Namespace, arg.Name)
	var i Bundle
	err := row.Scan(&i.ID, &i.Namespace, &i.Name)
	return i, err
}

const createStream = `-- name: CreateStream :one

INSERT INTO streams (bundle_id, version) VALUES ($1, $2) RETURNING bundle_id, version
`

type CreateStreamParams struct {
	BundleID uuid.UUID `json:"bundle_id"`
	Version  string    `json:"version"`
}

// Streams --
func (q *Queries) CreateStream(ctx context.Context, arg CreateStreamParams) (Stream, error) {
	row := q.db.QueryRowContext(ctx, createStream, arg.BundleID, arg.Version)
	var i Stream
	err := row.Scan(&i.BundleID, &i.Version)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one

INSERT INTO subscriptions (project_id, bundle_id, stream_version)
VALUES ($1, $2, $3)
RETURNING id, project_id, bundle_id, stream_version
`

type CreateSubscriptionParams struct {
	ProjectID     uuid.UUID `json:"project_id"`
	BundleID      uuid.UUID `json:"bundle_id"`
	StreamVersion string    `json:"stream_version"`
}

// Subscriptions --
func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription, arg.ProjectID, arg.BundleID, arg.StreamVersion)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.BundleID,
		&i.StreamVersion,
	)
	return i, err
}

const deleteBundle = `-- name: DeleteBundle :exec
DELETE FROM bundles WHERE namespace = $1 AND name = $2
`

type DeleteBundleParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

func (q *Queries) DeleteBundle(ctx context.Context, arg DeleteBundleParams) error {
	_, err := q.db.ExecContext(ctx, deleteBundle, arg.Namespace, arg.Name)
	return err
}

const deleteStream = `-- name: DeleteStream :exec
DELETE FROM streams
WHERE bundle_id IN (
    SELECT id FROM bundles WHERE namespace = $1 AND name = $2
)
`

type DeleteStreamParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

func (q *Queries) DeleteStream(ctx context.Context, arg DeleteStreamParams) error {
	_, err := q.db.ExecContext(ctx, deleteStream, arg.Namespace, arg.Name)
	return err
}

const getCurrentVersionByProjectBundle = `-- name: GetCurrentVersionByProjectBundle :one
SELECT st.version FROM subscriptions AS su
JOIN bundles AS bu ON bu.id = su.bundle_id
JOIN streams AS st ON st.bundle_id = su.bundle_id AND st.version = su.current_version
WHERE bu.namespace = $1 AND bu.name = $2 AND su.project_id = $3
`

type GetCurrentVersionByProjectBundleParams struct {
	Namespace string    `json:"namespace"`
	Name      string    `json:"name"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) GetCurrentVersionByProjectBundle(ctx context.Context, arg GetCurrentVersionByProjectBundleParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getCurrentVersionByProjectBundle, arg.Namespace, arg.Name, arg.ProjectID)
	var version string
	err := row.Scan(&version)
	return version, err
}

const getSubscriptionsByBundle = `-- name: GetSubscriptionsByBundle :many
SELECT (su.project_id, bu.namespace, bu.name)
FROM subscriptions AS su JOIN bundles AS bu ON bu.id = su.bundle_id
WHERE bu.namespace = $1 AND bu.name = $2
`

type GetSubscriptionsByBundleParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
}

func (q *Queries) GetSubscriptionsByBundle(ctx context.Context, arg GetSubscriptionsByBundleParams) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionsByBundle, arg.Namespace, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []interface{}{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCurrentVersion = `-- name: SetCurrentVersion :exec
UPDATE subscriptions
SET stream_version = $1
FROM subscriptions AS su
JOIN bundles as bu ON su.bundle_id = bu.id
WHERE su.project_id = $2 AND bu.namespace = $1 AND bu.name = $2
`

type SetCurrentVersionParams struct {
	StreamVersion string    `json:"stream_version"`
	ProjectID     uuid.UUID `json:"project_id"`
}

func (q *Queries) SetCurrentVersion(ctx context.Context, arg SetCurrentVersionParams) error {
	_, err := q.db.ExecContext(ctx, setCurrentVersion, arg.StreamVersion, arg.ProjectID)
	return err
}

const streamExists = `-- name: StreamExists :one
SELECT 1 FROM streams
JOIN bundles ON bundles.id = streams.bundle_id
WHERE bundles.namespace = $1 AND bundles.name = $2 AND streams.version = $3
`

type StreamExistsParams struct {
	Namespace string `json:"namespace"`
	Name      string `json:"name"`
	Version   string `json:"version"`
}

func (q *Queries) StreamExists(ctx context.Context, arg StreamExistsParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, streamExists, arg.Namespace, arg.Name, arg.Version)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}
