// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: eval_history.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getLatestEvalStateForRuleEntity = `-- name: GetLatestEvalStateForRuleEntity :one

SELECT eh.id, eh.rule_entity_id, eh.status, eh.details, eh.evaluation_time FROM evaluation_rule_entities AS re
JOIN latest_evaluation_statuses AS les ON les.rule_entity_id = re.id
JOIN evaluation_statuses AS eh ON les.evaluation_history_id = eh.id
WHERE re.rule_id = $1
AND (
    re.repository_id = $2
    OR re.pull_request_id = $3
    OR re.artifact_id = $4
)
FOR UPDATE
`

type GetLatestEvalStateForRuleEntityParams struct {
	RuleID        uuid.UUID     `json:"rule_id"`
	RepositoryID  uuid.NullUUID `json:"repository_id"`
	PullRequestID uuid.NullUUID `json:"pull_request_id"`
	ArtifactID    uuid.NullUUID `json:"artifact_id"`
}

// Copyright 2024 Stacklok, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
func (q *Queries) GetLatestEvalStateForRuleEntity(ctx context.Context, arg GetLatestEvalStateForRuleEntityParams) (EvaluationStatus, error) {
	row := q.db.QueryRowContext(ctx, getLatestEvalStateForRuleEntity,
		arg.RuleID,
		arg.RepositoryID,
		arg.PullRequestID,
		arg.ArtifactID,
	)
	var i EvaluationStatus
	err := row.Scan(
		&i.ID,
		&i.RuleEntityID,
		&i.Status,
		&i.Details,
		&i.EvaluationTime,
	)
	return i, err
}

const insertAlertEvent = `-- name: InsertAlertEvent :exec
INSERT INTO alert_events(
    evaluation_id,
    status,
    details,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertAlertEventParams struct {
	EvaluationID uuid.UUID        `json:"evaluation_id"`
	Status       AlertStatusTypes `json:"status"`
	Details      string           `json:"details"`
	Metadata     json.RawMessage  `json:"metadata"`
}

func (q *Queries) InsertAlertEvent(ctx context.Context, arg InsertAlertEventParams) error {
	_, err := q.db.ExecContext(ctx, insertAlertEvent,
		arg.EvaluationID,
		arg.Status,
		arg.Details,
		arg.Metadata,
	)
	return err
}

const insertEvaluationRuleEntity = `-- name: InsertEvaluationRuleEntity :one
INSERT INTO evaluation_rule_entities(
    rule_id,
    repository_id,
    pull_request_id,
    artifact_id
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING id
`

type InsertEvaluationRuleEntityParams struct {
	RuleID        uuid.UUID     `json:"rule_id"`
	RepositoryID  uuid.NullUUID `json:"repository_id"`
	PullRequestID uuid.NullUUID `json:"pull_request_id"`
	ArtifactID    uuid.NullUUID `json:"artifact_id"`
}

func (q *Queries) InsertEvaluationRuleEntity(ctx context.Context, arg InsertEvaluationRuleEntityParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertEvaluationRuleEntity,
		arg.RuleID,
		arg.RepositoryID,
		arg.PullRequestID,
		arg.ArtifactID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertEvaluationStatus = `-- name: InsertEvaluationStatus :one
INSERT INTO evaluation_statuses(
    rule_entity_id,
    status,
    details
) VALUES (
    $1,
    $2,
    $3
)
RETURNING id
`

type InsertEvaluationStatusParams struct {
	RuleEntityID uuid.UUID       `json:"rule_entity_id"`
	Status       EvalStatusTypes `json:"status"`
	Details      string          `json:"details"`
}

func (q *Queries) InsertEvaluationStatus(ctx context.Context, arg InsertEvaluationStatusParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertEvaluationStatus, arg.RuleEntityID, arg.Status, arg.Details)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertRemediationEvent = `-- name: InsertRemediationEvent :exec
INSERT INTO remediation_events(
    evaluation_id,
    status,
    details,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertRemediationEventParams struct {
	EvaluationID uuid.UUID              `json:"evaluation_id"`
	Status       RemediationStatusTypes `json:"status"`
	Details      string                 `json:"details"`
	Metadata     json.RawMessage        `json:"metadata"`
}

func (q *Queries) InsertRemediationEvent(ctx context.Context, arg InsertRemediationEventParams) error {
	_, err := q.db.ExecContext(ctx, insertRemediationEvent,
		arg.EvaluationID,
		arg.Status,
		arg.Details,
		arg.Metadata,
	)
	return err
}

const listEvaluationHistory = `-- name: ListEvaluationHistory :many
SELECT s.id::uuid AS evaluation_id,
       s.evaluation_time as evaluated_at,
       -- entity type
       CASE WHEN ere.repository_id IS NOT NULL THEN 'repository'::entities
            WHEN ere.pull_request_id IS NOT NULL THEN 'pull_request'::entities
            WHEN ere.artifact_id IS NOT NULL THEN 'artifact'::entities
       END AS entity_type,
       -- entity id
       CASE WHEN ere.repository_id IS NOT NULL THEN r.id
            WHEN ere.pull_request_id IS NOT NULL THEN pr.id
            WHEN ere.artifact_id IS NOT NULL THEN a.id
       END AS entity_id,
       -- raw fields for entity names
       r.repo_owner,
       r.repo_name,
       pr.pr_number,
       a.artifact_name,
       j.id as project_id,
       -- rule type, name, and profile
       rt.name AS rule_type,
       ri.name AS rule_name,
       p.name AS profile_name,
       -- evaluation status and details
       s.status AS evaluation_status,
       s.details AS evaluation_details,
       -- remediation status and details
       re.status AS remediation_status,
       re.details AS remediation_details,
       -- alert status and details
       ae.status AS alert_status,
       ae.details AS alert_details
  FROM evaluation_statuses s
  JOIN evaluation_rule_entities ere ON ere.id = s.rule_entity_id
  JOIN rule_instances ri ON ere.rule_id = ri.id
  JOIN rule_type rt ON ri.rule_type_id = rt.id
  JOIN profiles p ON ri.profile_id = p.id
  LEFT JOIN repositories r ON ere.repository_id = r.id
  LEFT JOIN pull_requests pr ON ere.pull_request_id = pr.id
  LEFT JOIN artifacts a ON ere.artifact_id = a.id
  LEFT JOIN remediation_events re ON re.evaluation_id = s.id
  LEFT JOIN alert_events ae ON ae.evaluation_id = s.id
  LEFT JOIN projects j ON r.project_id = j.id
 WHERE ($1::timestamp without time zone IS NULL OR $1 > s.evaluation_time)
   AND ($2::timestamp without time zone IS NULL OR $2 < s.evaluation_time)
   -- inclusion filters
   AND ($3::entities[] IS NULL OR entity_type::entities = ANY($3::entities[]))
   AND ($4::text[] IS NULL OR ere.repository_id IS NULL OR CONCAT(r.repo_owner, '/', r.repo_name) = ANY($4::text[]))
   AND ($4::text[] IS NULL OR ere.pull_request_id IS NULL OR pr.pr_number::text = ANY($4::text[]))
   AND ($4::text[] IS NULL OR ere.artifact_id IS NULL OR a.artifact_name = ANY($4::text[]))
   AND ($5::text[] IS NULL OR p.name = ANY($5::text[]))
   AND ($6::remediation_status_types[] IS NULL OR re.status = ANY($6::remediation_status_types[]))
   AND ($7::alert_status_types[] IS NULL OR ae.status = ANY($7::alert_status_types[]))
   AND ($8::eval_status_types[] IS NULL OR s.status = ANY($8::eval_status_types[]))
   -- exclusion filters
   AND ($9::entities[] IS NULL OR entity_type::entities != ANY($9::entities[]))
   AND ($10::text[] IS NULL OR ere.repository_id IS NULL OR CONCAT(r.repo_owner, '/', r.repo_name) != ANY($10::text[]))
   AND ($10::text[] IS NULL OR ere.pull_request_id IS NULL OR pr.pr_number::text != ANY($10::text[]))
   AND ($10::text[] IS NULL OR ere.artifact_id IS NULL OR a.artifact_name != ANY($10::text[]))
   AND ($11::text[] IS NULL OR p.name != ANY($11::text[]))
   AND ($12::remediation_status_types[] IS NULL OR re.status != ANY($12::remediation_status_types[]))
   AND ($13::alert_status_types[] IS NULL OR ae.status != ANY($13::alert_status_types[]))
   AND ($14::eval_status_types[] IS NULL OR s.status != ANY($14::eval_status_types[]))
   -- time range filter
   AND ($15::timestamp without time zone IS NULL
        OR $16::timestamp without time zone IS NULL
        OR s.evaluation_time BETWEEN $15 AND $16)
   -- implicit filter by project id
   AND j.id = $17
 ORDER BY s.evaluation_time DESC
 LIMIT $18::integer
`

type ListEvaluationHistoryParams struct {
	Next            sql.NullTime             `json:"next"`
	Prev            sql.NullTime             `json:"prev"`
	Entitytypes     []Entities               `json:"entitytypes"`
	Entitynames     []string                 `json:"entitynames"`
	Profilenames    []string                 `json:"profilenames"`
	Remediations    []RemediationStatusTypes `json:"remediations"`
	Alerts          []AlertStatusTypes       `json:"alerts"`
	Statuses        []EvalStatusTypes        `json:"statuses"`
	Notentitytypes  []Entities               `json:"notentitytypes"`
	Notentitynames  []string                 `json:"notentitynames"`
	Notprofilenames []string                 `json:"notprofilenames"`
	Notremediations []RemediationStatusTypes `json:"notremediations"`
	Notalerts       []AlertStatusTypes       `json:"notalerts"`
	Notstatuses     []EvalStatusTypes        `json:"notstatuses"`
	Fromts          sql.NullTime             `json:"fromts"`
	Tots            sql.NullTime             `json:"tots"`
	Projectid       uuid.UUID                `json:"projectid"`
	Size            int32                    `json:"size"`
}

type ListEvaluationHistoryRow struct {
	EvaluationID       uuid.UUID                  `json:"evaluation_id"`
	EvaluatedAt        time.Time                  `json:"evaluated_at"`
	EntityType         interface{}                `json:"entity_type"`
	EntityID           interface{}                `json:"entity_id"`
	RepoOwner          sql.NullString             `json:"repo_owner"`
	RepoName           sql.NullString             `json:"repo_name"`
	PrNumber           sql.NullInt64              `json:"pr_number"`
	ArtifactName       sql.NullString             `json:"artifact_name"`
	ProjectID          uuid.NullUUID              `json:"project_id"`
	RuleType           string                     `json:"rule_type"`
	RuleName           string                     `json:"rule_name"`
	ProfileName        string                     `json:"profile_name"`
	EvaluationStatus   EvalStatusTypes            `json:"evaluation_status"`
	EvaluationDetails  string                     `json:"evaluation_details"`
	RemediationStatus  NullRemediationStatusTypes `json:"remediation_status"`
	RemediationDetails sql.NullString             `json:"remediation_details"`
	AlertStatus        NullAlertStatusTypes       `json:"alert_status"`
	AlertDetails       sql.NullString             `json:"alert_details"`
}

func (q *Queries) ListEvaluationHistory(ctx context.Context, arg ListEvaluationHistoryParams) ([]ListEvaluationHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listEvaluationHistory,
		arg.Next,
		arg.Prev,
		pq.Array(arg.Entitytypes),
		pq.Array(arg.Entitynames),
		pq.Array(arg.Profilenames),
		pq.Array(arg.Remediations),
		pq.Array(arg.Alerts),
		pq.Array(arg.Statuses),
		pq.Array(arg.Notentitytypes),
		pq.Array(arg.Notentitynames),
		pq.Array(arg.Notprofilenames),
		pq.Array(arg.Notremediations),
		pq.Array(arg.Notalerts),
		pq.Array(arg.Notstatuses),
		arg.Fromts,
		arg.Tots,
		arg.Projectid,
		arg.Size,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEvaluationHistoryRow{}
	for rows.Next() {
		var i ListEvaluationHistoryRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluatedAt,
			&i.EntityType,
			&i.EntityID,
			&i.RepoOwner,
			&i.RepoName,
			&i.PrNumber,
			&i.ArtifactName,
			&i.ProjectID,
			&i.RuleType,
			&i.RuleName,
			&i.ProfileName,
			&i.EvaluationStatus,
			&i.EvaluationDetails,
			&i.RemediationStatus,
			&i.RemediationDetails,
			&i.AlertStatus,
			&i.AlertDetails,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLatestEvaluationStatus = `-- name: UpsertLatestEvaluationStatus :exec
INSERT INTO latest_evaluation_statuses(
    rule_entity_id,
    evaluation_history_id
) VALUES (
    $1,
    $2
)
ON CONFLICT (rule_entity_id) DO UPDATE
SET evaluation_history_id = $2
`

type UpsertLatestEvaluationStatusParams struct {
	RuleEntityID        uuid.UUID `json:"rule_entity_id"`
	EvaluationHistoryID uuid.UUID `json:"evaluation_history_id"`
}

func (q *Queries) UpsertLatestEvaluationStatus(ctx context.Context, arg UpsertLatestEvaluationStatusParams) error {
	_, err := q.db.ExecContext(ctx, upsertLatestEvaluationStatus, arg.RuleEntityID, arg.EvaluationHistoryID)
	return err
}
