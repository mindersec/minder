// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: policies.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createPolicy = `-- name: CreatePolicy :one
INSERT INTO policies (  
    provider,
    group_id,
    policy_type,
    policy_definition) VALUES ($1, $2, $3, $4::jsonb) RETURNING id, provider, group_id, policy_type, policy_definition, created_at, updated_at
`

type CreatePolicyParams struct {
	Provider         string          `json:"provider"`
	GroupID          int32           `json:"group_id"`
	PolicyType       int32           `json:"policy_type"`
	PolicyDefinition json.RawMessage `json:"policy_definition"`
}

func (q *Queries) CreatePolicy(ctx context.Context, arg CreatePolicyParams) (Policy, error) {
	row := q.db.QueryRowContext(ctx, createPolicy,
		arg.Provider,
		arg.GroupID,
		arg.PolicyType,
		arg.PolicyDefinition,
	)
	var i Policy
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.GroupID,
		&i.PolicyType,
		&i.PolicyDefinition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePolicy = `-- name: DeletePolicy :exec
DELETE FROM policies
WHERE id = $1
`

func (q *Queries) DeletePolicy(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePolicy, id)
	return err
}

const getPoliciesByRepoAndType = `-- name: GetPoliciesByRepoAndType :many
SELECT p.id, p.provider, p.group_id, p.policy_type, p.policy_definition FROM repositories r
INNER JOIN policies p ON p.provider=r.provider AND p.group_id=r.group_id AND
p.policy_type=(SELECT id FROM policy_types pt WHERE pt.provider=p.provider AND pt.policy_type=$2)
WHERE r.provider = $1 AND r.repo_id = $3
`

type GetPoliciesByRepoAndTypeParams struct {
	Provider   string `json:"provider"`
	PolicyType string `json:"policy_type"`
	RepoID     int32  `json:"repo_id"`
}

type GetPoliciesByRepoAndTypeRow struct {
	ID               int32           `json:"id"`
	Provider         string          `json:"provider"`
	GroupID          int32           `json:"group_id"`
	PolicyType       int32           `json:"policy_type"`
	PolicyDefinition json.RawMessage `json:"policy_definition"`
}

func (q *Queries) GetPoliciesByRepoAndType(ctx context.Context, arg GetPoliciesByRepoAndTypeParams) ([]GetPoliciesByRepoAndTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getPoliciesByRepoAndType, arg.Provider, arg.PolicyType, arg.RepoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPoliciesByRepoAndTypeRow{}
	for rows.Next() {
		var i GetPoliciesByRepoAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.GroupID,
			&i.PolicyType,
			&i.PolicyDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolicyByID = `-- name: GetPolicyByID :one
SELECT policies.id as id, policies.provider as provider, group_id, policies.policy_type as policy_type,
policy_definition, policy_types.policy_type as policy_type_name,
policies.created_at as created_at, policies.updated_at as updated_at FROM policies
LEFT OUTER JOIN policy_types ON policy_types.id = policies.policy_type WHERE policies.id = $1
`

type GetPolicyByIDRow struct {
	ID               int32           `json:"id"`
	Provider         string          `json:"provider"`
	GroupID          int32           `json:"group_id"`
	PolicyType       int32           `json:"policy_type"`
	PolicyDefinition json.RawMessage `json:"policy_definition"`
	PolicyTypeName   sql.NullString  `json:"policy_type_name"`
	CreatedAt        time.Time       `json:"created_at"`
	UpdatedAt        time.Time       `json:"updated_at"`
}

func (q *Queries) GetPolicyByID(ctx context.Context, id int32) (GetPolicyByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPolicyByID, id)
	var i GetPolicyByIDRow
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.GroupID,
		&i.PolicyType,
		&i.PolicyDefinition,
		&i.PolicyTypeName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPoliciesByGroupID = `-- name: ListPoliciesByGroupID :many
SELECT policies.id as id, policies.provider as provider, group_id, policies.policy_type as policy_type,
policy_definition, policy_types.policy_type as policy_type_name,
policies.created_at as created_at, policies.updated_at as updated_at FROM policies
LEFT OUTER JOIN policy_types ON policy_types.id = policies.policy_type
WHERE policies.provider = $1 AND group_id = $2
ORDER BY id
LIMIT $3
OFFSET $4
`

type ListPoliciesByGroupIDParams struct {
	Provider string `json:"provider"`
	GroupID  int32  `json:"group_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type ListPoliciesByGroupIDRow struct {
	ID               int32           `json:"id"`
	Provider         string          `json:"provider"`
	GroupID          int32           `json:"group_id"`
	PolicyType       int32           `json:"policy_type"`
	PolicyDefinition json.RawMessage `json:"policy_definition"`
	PolicyTypeName   sql.NullString  `json:"policy_type_name"`
	CreatedAt        time.Time       `json:"created_at"`
	UpdatedAt        time.Time       `json:"updated_at"`
}

func (q *Queries) ListPoliciesByGroupID(ctx context.Context, arg ListPoliciesByGroupIDParams) ([]ListPoliciesByGroupIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listPoliciesByGroupID,
		arg.Provider,
		arg.GroupID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPoliciesByGroupIDRow{}
	for rows.Next() {
		var i ListPoliciesByGroupIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.GroupID,
			&i.PolicyType,
			&i.PolicyDefinition,
			&i.PolicyTypeName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
